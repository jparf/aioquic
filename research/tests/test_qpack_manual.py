"""Tests for the manual QPACK encoder (Phase 1).

Cross-validates against pylsqpack.Decoder to prove our generated bytes
are valid QPACK that any conformant decoder must accept.
"""

from unittest import TestCase

import pylsqpack

from research.qpack_manual import (
    DynamicTableTracker,
    ManualQpackEncoder,
    decode_integer,
    duplicate,
    encode_integer,
    encode_string,
    insert_with_literal_name,
    insert_with_name_ref,
    set_dynamic_table_capacity,
)
from research.qpack_static_table import STATIC_TABLE, STATIC_TABLE_SIZE


# ---------------------------------------------------------------------------
# Integer encoding/decoding
# ---------------------------------------------------------------------------


class IntegerEncodingTest(TestCase):
    def test_zero(self):
        for prefix in range(1, 9):
            result = encode_integer(0, prefix)
            self.assertEqual(result, b"\x00")

    def test_fits_in_prefix(self):
        # 5-bit prefix, value 10 < 31
        result = encode_integer(10, 5)
        self.assertEqual(result, bytes([10]))

    def test_max_prefix_value(self):
        # 5-bit prefix, value 30 = 2^5 - 2 (still fits)
        result = encode_integer(30, 5)
        self.assertEqual(result, bytes([30]))

    def test_needs_continuation(self):
        # 5-bit prefix, value 31 = 2^5 - 1 → needs continuation
        result = encode_integer(31, 5)
        # First byte: 0x1f (31), then 31-31=0 → one continuation byte: 0x00
        self.assertEqual(result, bytes([0x1F, 0x00]))

    def test_multi_byte(self):
        # 5-bit prefix, value 1337
        result = encode_integer(1337, 5)
        # 1337: first byte 0x1f (31), remaining = 1337-31 = 1306
        # 1306 = 0x51a → 0x1a | 0x80 = 0x9a, then 0x0a
        self.assertEqual(result, bytes([0x1F, 0x9A, 0x0A]))

    def test_large_value(self):
        # Value 256 with 5-bit prefix
        result = encode_integer(256, 5)
        # 256: first byte 0x1f, remaining = 256-31=225
        # 225 = 0xe1: 225 >= 128 → 225 & 0x7f = 0x61 | 0x80 = 0xe1, 225 >> 7 = 1
        # 1 < 128 → 0x01
        self.assertEqual(result, bytes([0x1F, 0xE1, 0x01]))

    def test_1_bit_prefix(self):
        # 1-bit prefix, value 0 fits
        self.assertEqual(encode_integer(0, 1), b"\x00")
        # 1-bit prefix, value 1 needs continuation (max prefix = 1)
        result = encode_integer(1, 1)
        self.assertEqual(result, bytes([0x01, 0x00]))

    def test_8_bit_prefix(self):
        # 8-bit prefix, value 254 fits
        self.assertEqual(encode_integer(254, 8), bytes([254]))
        # 8-bit prefix, value 255 needs continuation (max prefix = 255)
        result = encode_integer(255, 8)
        self.assertEqual(result, bytes([0xFF, 0x00]))

    def test_negative_raises(self):
        with self.assertRaises(ValueError):
            encode_integer(-1, 5)

    def test_invalid_prefix_raises(self):
        with self.assertRaises(ValueError):
            encode_integer(0, 0)
        with self.assertRaises(ValueError):
            encode_integer(0, 9)

    def test_roundtrip(self):
        """Encode then decode various values and prefix widths."""
        for prefix in range(1, 9):
            for value in [0, 1, 10, 31, 127, 128, 255, 256, 1337, 65535]:
                encoded = encode_integer(value, prefix)
                decoded_val, consumed = decode_integer(encoded, 0, prefix)
                self.assertEqual(decoded_val, value, f"prefix={prefix}, value={value}")
                self.assertEqual(consumed, len(encoded))


class IntegerDecodingTest(TestCase):
    def test_single_byte(self):
        val, consumed = decode_integer(bytes([10]), 0, 5)
        self.assertEqual(val, 10)
        self.assertEqual(consumed, 1)

    def test_multi_byte(self):
        val, consumed = decode_integer(bytes([0x1F, 0x9A, 0x0A]), 0, 5)
        self.assertEqual(val, 1337)
        self.assertEqual(consumed, 3)

    def test_with_offset(self):
        data = bytes([0xFF, 0x1F, 0x00])
        val, consumed = decode_integer(data, 1, 5)
        self.assertEqual(val, 31)
        self.assertEqual(consumed, 2)

    def test_pattern_bits_masked(self):
        # First byte has pattern bits in upper bits that should be masked
        data = bytes([0xE0 | 10])  # upper 3 bits set, lower 5 = 10
        val, consumed = decode_integer(data, 0, 5)
        self.assertEqual(val, 10)
        self.assertEqual(consumed, 1)

    def test_truncated_raises(self):
        with self.assertRaises(ValueError):
            # Needs continuation but no more bytes
            decode_integer(bytes([0x1F]), 0, 5)


# ---------------------------------------------------------------------------
# String encoding
# ---------------------------------------------------------------------------


class StringEncodingTest(TestCase):
    def test_empty(self):
        result = encode_string(b"")
        self.assertEqual(result, b"\x00")

    def test_short(self):
        result = encode_string(b"abc")
        self.assertEqual(result, bytes([3]) + b"abc")

    def test_long(self):
        value = b"x" * 200
        result = encode_string(value)
        # Length 200: 7-bit prefix max = 127, so multi-byte
        length_part = encode_integer(200, 7)
        self.assertEqual(result, length_part + value)

    def test_huffman_not_supported(self):
        with self.assertRaises(NotImplementedError):
            encode_string(b"test", use_huffman=True)


# ---------------------------------------------------------------------------
# Encoder stream instructions
# ---------------------------------------------------------------------------


class SetDynamicTableCapacityTest(TestCase):
    def test_small(self):
        result = set_dynamic_table_capacity(0)
        self.assertEqual(result, bytes([0x20]))  # 0b001_00000

    def test_value_fits_prefix(self):
        result = set_dynamic_table_capacity(10)
        self.assertEqual(result, bytes([0x20 | 10]))  # 0b001_01010

    def test_value_needs_continuation(self):
        # Capacity 256 with 5-bit prefix
        result = set_dynamic_table_capacity(256)
        # encode_integer(256, 5) = [0x1f, 0xe1, 0x01]
        # OR with 0x20 → [0x3f, 0xe1, 0x01]
        self.assertEqual(result, bytes([0x3F, 0xE1, 0x01]))

    def test_matches_pylsqpack_apply_settings(self):
        """Verify our output matches pylsqpack.Encoder.apply_settings."""
        # From test_roundtrip.py: apply_settings(0x100, 0x10) → b"\x3f\xe1\x01"
        result = set_dynamic_table_capacity(0x100)
        self.assertEqual(result, b"\x3f\xe1\x01")

    def test_4096(self):
        result = set_dynamic_table_capacity(4096)
        # 4096 with 5-bit prefix: 31 + continuation
        # 4096 - 31 = 4065. 4065 in 7-bit chunks:
        # 4065 & 0x7f = 0x61 | 0x80 = 0xe1
        # 4065 >> 7 = 31. 31 & 0x7f = 0x1f (< 128, no continuation)
        self.assertEqual(result, bytes([0x3F, 0xE1, 0x1F]))

    def test_negative_raises(self):
        with self.assertRaises(ValueError):
            set_dynamic_table_capacity(-1)


class InsertWithNameRefTest(TestCase):
    def test_static_ref(self):
        # Static index 0 (:authority), value "example.com"
        result = insert_with_name_ref(0, b"example.com", is_static=True)
        # First byte: 0x80 | 0x40 | 0 = 0xc0, then value string
        expected = bytes([0xC0]) + encode_string(b"example.com")
        self.assertEqual(result, expected)

    def test_static_ref_large_index(self):
        # Static index 98 (last entry)
        result = insert_with_name_ref(98, b"test", is_static=True)
        # 98 with 6-bit prefix: max=63, 98-63=35
        int_bytes = encode_integer(98, 6)
        buf = bytearray(int_bytes)
        buf[0] |= 0x80 | 0x40
        expected = bytes(buf) + encode_string(b"test")
        self.assertEqual(result, expected)

    def test_dynamic_ref(self):
        result = insert_with_name_ref(0, b"val", is_static=False)
        # First byte: 0x80 | 0 = 0x80, then value string
        expected = bytes([0x80]) + encode_string(b"val")
        self.assertEqual(result, expected)

    def test_negative_index_raises(self):
        with self.assertRaises(ValueError):
            insert_with_name_ref(-1, b"val", is_static=True)


class InsertWithLiteralNameTest(TestCase):
    def test_simple(self):
        result = insert_with_literal_name(b"x-custom", b"value")
        # Name string: encode_string(b"x-custom") = [8] + b"x-custom"
        # First byte OR'd with 0x40: [8 | 0x40] = [0x48]
        # Then value: encode_string(b"value") = [5] + b"value"
        name_part = bytearray(encode_string(b"x-custom"))
        name_part[0] |= 0x40
        expected = bytes(name_part) + encode_string(b"value")
        self.assertEqual(result, expected)

    def test_empty_value(self):
        result = insert_with_literal_name(b"x-test", b"")
        name_part = bytearray(encode_string(b"x-test"))
        name_part[0] |= 0x40
        expected = bytes(name_part) + b"\x00"
        self.assertEqual(result, expected)


class DuplicateTest(TestCase):
    def test_zero(self):
        result = duplicate(0)
        self.assertEqual(result, bytes([0x00]))

    def test_small(self):
        result = duplicate(5)
        self.assertEqual(result, bytes([5]))

    def test_large(self):
        result = duplicate(31)
        # 5-bit prefix, 31 needs continuation
        self.assertEqual(result, bytes([0x1F, 0x00]))

    def test_negative_raises(self):
        with self.assertRaises(ValueError):
            duplicate(-1)


# ---------------------------------------------------------------------------
# Dynamic Table Tracker
# ---------------------------------------------------------------------------


class DynamicTableTrackerTest(TestCase):
    def test_initial_state(self):
        t = DynamicTableTracker()
        self.assertEqual(t.entries, [])
        self.assertEqual(t.capacity, 0)
        self.assertEqual(t.insert_count, 0)
        self.assertEqual(t.current_size(), 0)

    def test_set_capacity(self):
        t = DynamicTableTracker()
        t.set_capacity(4096)
        self.assertEqual(t.capacity, 4096)

    def test_insert(self):
        t = DynamicTableTracker()
        t.set_capacity(4096)
        t.insert(b"x-custom", b"value")
        self.assertEqual(len(t.entries), 1)
        self.assertEqual(t.entries[0].name, b"x-custom")
        self.assertEqual(t.entries[0].value, b"value")
        self.assertEqual(t.entries[0].size, 8 + 5 + 32)
        self.assertEqual(t.insert_count, 1)

    def test_insert_newest_first(self):
        t = DynamicTableTracker()
        t.set_capacity(4096)
        t.insert(b"first", b"1")
        t.insert(b"second", b"2")
        self.assertEqual(t.entries[0].name, b"second")
        self.assertEqual(t.entries[1].name, b"first")
        self.assertEqual(t.insert_count, 2)

    def test_insert_exceeds_capacity_raises(self):
        t = DynamicTableTracker()
        t.set_capacity(40)  # Only room for overhead + 8 bytes
        with self.assertRaises(ValueError):
            t.insert(b"x-custom", b"value")  # 8 + 5 + 32 = 45 > 40

    def test_eviction_on_insert(self):
        t = DynamicTableTracker()
        # Each entry: 1 + 1 + 32 = 34 bytes
        t.set_capacity(68)  # Room for exactly 2 entries of size 34
        t.insert(b"a", b"1")
        t.insert(b"b", b"2")
        self.assertEqual(len(t.entries), 2)
        # Third insert evicts the oldest
        t.insert(b"c", b"3")
        self.assertEqual(len(t.entries), 2)
        self.assertEqual(t.entries[0].name, b"c")
        self.assertEqual(t.entries[1].name, b"b")

    def test_eviction_on_capacity_reduction(self):
        t = DynamicTableTracker()
        t.set_capacity(4096)
        t.insert(b"a", b"1")
        t.insert(b"b", b"2")
        # Reduce capacity to fit only 1 entry
        t.set_capacity(34)
        self.assertEqual(len(t.entries), 1)
        self.assertEqual(t.entries[0].name, b"b")  # newest survives

    def test_duplicate(self):
        t = DynamicTableTracker()
        t.set_capacity(4096)
        t.insert(b"original", b"val")
        t.duplicate(0)
        self.assertEqual(len(t.entries), 2)
        self.assertEqual(t.entries[0].name, b"original")
        self.assertEqual(t.entries[0].value, b"val")
        self.assertEqual(t.entries[1].name, b"original")
        self.assertEqual(t.insert_count, 2)

    def test_duplicate_invalid_index_raises(self):
        t = DynamicTableTracker()
        t.set_capacity(4096)
        with self.assertRaises(ValueError):
            t.duplicate(0)  # empty table


# ---------------------------------------------------------------------------
# ManualQpackEncoder
# ---------------------------------------------------------------------------


class ManualQpackEncoderTest(TestCase):
    def test_set_capacity(self):
        enc = ManualQpackEncoder(max_table_capacity=4096)
        result = enc.set_capacity(4096)
        self.assertEqual(result, set_dynamic_table_capacity(4096))
        self.assertEqual(enc.table.capacity, 4096)

    def test_set_capacity_exceeds_max_raises(self):
        enc = ManualQpackEncoder(max_table_capacity=1024)
        with self.assertRaises(ValueError):
            enc.set_capacity(2048)

    def test_insert_name_ref_static(self):
        enc = ManualQpackEncoder(max_table_capacity=4096)
        enc.set_capacity(4096)
        result = enc.insert_name_ref(0, b"example.com", is_static=True)
        # Should update tracker
        self.assertEqual(len(enc.table.entries), 1)
        self.assertEqual(enc.table.entries[0].name, b":authority")
        self.assertEqual(enc.table.entries[0].value, b"example.com")

    def test_insert_name_ref_static_invalid_index_raises(self):
        enc = ManualQpackEncoder(max_table_capacity=4096)
        enc.set_capacity(4096)
        with self.assertRaises(ValueError):
            enc.insert_name_ref(99, b"val", is_static=True)

    def test_insert_name_ref_dynamic(self):
        enc = ManualQpackEncoder(max_table_capacity=4096)
        enc.set_capacity(4096)
        enc.insert_literal(b"x-custom", b"val1")
        result = enc.insert_name_ref(0, b"val2", is_static=False)
        self.assertEqual(len(enc.table.entries), 2)
        self.assertEqual(enc.table.entries[0].name, b"x-custom")
        self.assertEqual(enc.table.entries[0].value, b"val2")

    def test_insert_name_ref_dynamic_invalid_index_raises(self):
        enc = ManualQpackEncoder(max_table_capacity=4096)
        enc.set_capacity(4096)
        with self.assertRaises(ValueError):
            enc.insert_name_ref(0, b"val", is_static=False)

    def test_insert_literal(self):
        enc = ManualQpackEncoder(max_table_capacity=4096)
        enc.set_capacity(4096)
        result = enc.insert_literal(b"x-test", b"hello")
        self.assertEqual(len(enc.table.entries), 1)
        self.assertEqual(enc.table.entries[0].name, b"x-test")
        self.assertEqual(enc.table.entries[0].value, b"hello")

    def test_insert_literal_no_capacity_raises(self):
        enc = ManualQpackEncoder(max_table_capacity=4096)
        # capacity is still 0
        with self.assertRaises(ValueError):
            enc.insert_literal(b"x-test", b"hello")

    def test_duplicate(self):
        enc = ManualQpackEncoder(max_table_capacity=4096)
        enc.set_capacity(4096)
        enc.insert_literal(b"x-test", b"val")
        result = enc.duplicate(0)
        self.assertEqual(len(enc.table.entries), 2)
        self.assertEqual(enc.table.entries[0].name, b"x-test")
        self.assertEqual(enc.table.entries[0].value, b"val")

    def test_duplicate_invalid_index_raises(self):
        enc = ManualQpackEncoder(max_table_capacity=4096)
        enc.set_capacity(4096)
        with self.assertRaises(ValueError):
            enc.duplicate(0)

    def test_max_table_capacity_property(self):
        enc = ManualQpackEncoder(max_table_capacity=1024)
        self.assertEqual(enc.max_table_capacity, 1024)
        enc.max_table_capacity = 2048
        self.assertEqual(enc.max_table_capacity, 2048)


# ---------------------------------------------------------------------------
# Cross-validation with pylsqpack.Decoder
# ---------------------------------------------------------------------------


class CrossValidationTest(TestCase):
    """Feed our manually-generated encoder stream bytes into a real
    pylsqpack.Decoder to verify they are valid QPACK."""

    def _make_decoder(self, capacity=4096):
        return pylsqpack.Decoder(capacity, 16)

    def test_set_capacity(self):
        encoder = ManualQpackEncoder(max_table_capacity=4096)
        decoder = self._make_decoder(4096)

        cap_bytes = encoder.set_capacity(4096)
        # Must not raise EncoderStreamError
        decoder.feed_encoder(cap_bytes)

    def test_set_capacity_256(self):
        """Verify against known pylsqpack output for capacity 256."""
        encoder = ManualQpackEncoder(max_table_capacity=0x100)
        decoder = self._make_decoder(0x100)

        cap_bytes = encoder.set_capacity(0x100)
        # Known from test_roundtrip: apply_settings(0x100, 0x10) → b"\x3f\xe1\x01"
        self.assertEqual(cap_bytes, b"\x3f\xe1\x01")
        decoder.feed_encoder(cap_bytes)

    def test_insert_literal(self):
        encoder = ManualQpackEncoder(max_table_capacity=4096)
        decoder = self._make_decoder(4096)

        # Set capacity first
        decoder.feed_encoder(encoder.set_capacity(4096))

        # Insert a literal entry
        inst = encoder.insert_literal(b"x-custom", b"hello-world")
        decoder.feed_encoder(inst)

        # Verify decoder's dynamic table matches
        dt = decoder.get_dynamic_table()
        self.assertEqual(
            dt["entries"], [(b"x-custom", b"hello-world")]
        )
        # current_capacity = 8 + 11 + 32 = 51
        self.assertEqual(dt["current_capacity"], 51)
        # Verify our tracker matches
        self.assertEqual(encoder.table.insert_count, 1)
        self.assertEqual(encoder.table.entries[0].name, b"x-custom")
        self.assertEqual(encoder.table.entries[0].value, b"hello-world")

    def test_insert_name_ref_static(self):
        encoder = ManualQpackEncoder(max_table_capacity=4096)
        decoder = self._make_decoder(4096)

        decoder.feed_encoder(encoder.set_capacity(4096))

        # Insert with static name reference: index 0 = :authority
        inst = encoder.insert_name_ref(0, b"example.com", is_static=True)
        decoder.feed_encoder(inst)

        dt = decoder.get_dynamic_table()
        self.assertEqual(
            dt["entries"], [(b":authority", b"example.com")]
        )

    def test_insert_name_ref_dynamic(self):
        encoder = ManualQpackEncoder(max_table_capacity=4096)
        decoder = self._make_decoder(4096)

        decoder.feed_encoder(encoder.set_capacity(4096))

        # First insert a literal entry
        decoder.feed_encoder(encoder.insert_literal(b"x-custom", b"val1"))

        # Then insert with dynamic name reference to the just-inserted entry
        inst = encoder.insert_name_ref(0, b"val2", is_static=False)
        decoder.feed_encoder(inst)

        dt = decoder.get_dynamic_table()
        entries = dt["entries"]
        self.assertEqual(len(entries), 2)
        self.assertIn((b"x-custom", b"val2"), entries)
        self.assertIn((b"x-custom", b"val1"), entries)

    def test_duplicate(self):
        encoder = ManualQpackEncoder(max_table_capacity=4096)
        decoder = self._make_decoder(4096)

        decoder.feed_encoder(encoder.set_capacity(4096))
        decoder.feed_encoder(encoder.insert_literal(b"x-dup", b"original"))

        inst = encoder.duplicate(0)
        decoder.feed_encoder(inst)

        dt = decoder.get_dynamic_table()
        entries = dt["entries"]
        self.assertEqual(len(entries), 2)
        for name, value in entries:
            self.assertEqual(name, b"x-dup")
            self.assertEqual(value, b"original")

    def test_multiple_operations(self):
        """Chain several operations and verify decoder stays in sync."""
        encoder = ManualQpackEncoder(max_table_capacity=4096)
        decoder = self._make_decoder(4096)

        decoder.feed_encoder(encoder.set_capacity(4096))

        # Insert several entries
        decoder.feed_encoder(encoder.insert_literal(b"x-one", b"1"))
        decoder.feed_encoder(encoder.insert_literal(b"x-two", b"2"))
        decoder.feed_encoder(
            encoder.insert_name_ref(17, b"GET-custom", is_static=True)
        )  # :method
        decoder.feed_encoder(encoder.duplicate(0))

        dt = decoder.get_dynamic_table()
        self.assertEqual(encoder.table.insert_count, 4)
        self.assertEqual(len(dt["entries"]), 4)
        self.assertEqual(len(dt["entries"]), len(encoder.table.entries))

    def test_eviction_matches_decoder(self):
        """Verify our eviction logic matches the real decoder."""
        # Use a small capacity to force evictions
        cap = 128
        encoder = ManualQpackEncoder(max_table_capacity=cap)
        decoder = self._make_decoder(cap)

        decoder.feed_encoder(encoder.set_capacity(cap))

        # Insert entries until eviction happens
        # Each entry: name_len + value_len + 32
        # b"hdr-X" (5) + b"val" (3) + 32 = 40 bytes → 3 fit in 128, 4th evicts
        for i in range(5):
            name = f"hdr-{i}".encode()
            value = b"val"
            decoder.feed_encoder(encoder.insert_literal(name, value))

        dt = decoder.get_dynamic_table()
        entries = dt["entries"]
        # Both should agree on the number of entries present
        self.assertEqual(len(entries), len(encoder.table.entries))

        # Verify the actual header names match
        decoder_names = [h[0] for h in entries]
        encoder_names = [e.name for e in encoder.table.entries]
        self.assertEqual(set(decoder_names), set(encoder_names))

        # Verify sizes match
        self.assertEqual(dt["current_capacity"], encoder.table.current_size())

    def test_capacity_reduction(self):
        """Reduce capacity and verify eviction matches decoder."""
        encoder = ManualQpackEncoder(max_table_capacity=4096)
        decoder = self._make_decoder(4096)

        decoder.feed_encoder(encoder.set_capacity(4096))
        decoder.feed_encoder(encoder.insert_literal(b"x-big", b"a" * 100))
        decoder.feed_encoder(encoder.insert_literal(b"x-small", b"b"))

        # Reduce capacity to only fit the small entry
        # x-small: 7 + 1 + 32 = 40
        decoder.feed_encoder(encoder.set_capacity(40))

        dt = decoder.get_dynamic_table()
        self.assertEqual(len(dt["entries"]), len(encoder.table.entries))
        self.assertEqual(dt["current_capacity"], encoder.table.current_size())

    def test_all_static_name_refs(self):
        """Insert with name reference for several static table entries."""
        encoder = ManualQpackEncoder(max_table_capacity=4096)
        decoder = self._make_decoder(4096)

        decoder.feed_encoder(encoder.set_capacity(4096))

        # Test a selection of static table indices
        test_indices = [0, 1, 17, 25, 29, 98]
        for idx in test_indices:
            inst = encoder.insert_name_ref(idx, b"test", is_static=True)
            decoder.feed_encoder(inst)

        dt = decoder.get_dynamic_table()
        entries = dt["entries"]
        self.assertEqual(len(entries), len(test_indices))

        # Verify names match the static table
        # Decoder lists entries oldest-first (insertion order)
        for i, idx in enumerate(test_indices):
            expected_name = STATIC_TABLE[idx][0]
            actual_name = entries[i][0]
            self.assertEqual(actual_name, expected_name)


# ---------------------------------------------------------------------------
# Static table sanity check
# ---------------------------------------------------------------------------


class StaticTableTest(TestCase):
    def test_size(self):
        self.assertEqual(STATIC_TABLE_SIZE, 99)

    def test_first_entry(self):
        self.assertEqual(STATIC_TABLE[0], (b":authority", b""))

    def test_last_entry(self):
        self.assertEqual(STATIC_TABLE[98], (b"x-frame-options", b"sameorigin"))

    def test_all_entries_are_bytes(self):
        for i, (name, value) in enumerate(STATIC_TABLE):
            self.assertIsInstance(name, bytes, f"entry {i} name is not bytes")
            self.assertIsInstance(value, bytes, f"entry {i} value is not bytes")
